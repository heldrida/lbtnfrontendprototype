(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
(function (process){
module.exports = process.env.MEDIATOR_JS_COV
  ? require('./lib-cov/mediator')
  : require('./lib/mediator');

}).call(this,require('_process'))
},{"./lib-cov/mediator":3,"./lib/mediator":4,"_process":1}],3:[function(require,module,exports){
/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['mediator.js']) {
  _$jscoverage['mediator.js'] = [];
  _$jscoverage['mediator.js'][16] = 0;
  _$jscoverage['mediator.js'][17] = 0;
  _$jscoverage['mediator.js'][19] = 0;
  _$jscoverage['mediator.js'][21] = 0;
  _$jscoverage['mediator.js'][22] = 0;
  _$jscoverage['mediator.js'][24] = 0;
  _$jscoverage['mediator.js'][26] = 0;
  _$jscoverage['mediator.js'][30] = 0;
  _$jscoverage['mediator.js'][33] = 0;
  _$jscoverage['mediator.js'][39] = 0;
  _$jscoverage['mediator.js'][40] = 0;
  _$jscoverage['mediator.js'][41] = 0;
  _$jscoverage['mediator.js'][44] = 0;
  _$jscoverage['mediator.js'][52] = 0;
  _$jscoverage['mediator.js'][53] = 0;
  _$jscoverage['mediator.js'][54] = 0;
  _$jscoverage['mediator.js'][57] = 0;
  _$jscoverage['mediator.js'][58] = 0;
  _$jscoverage['mediator.js'][59] = 0;
  _$jscoverage['mediator.js'][60] = 0;
  _$jscoverage['mediator.js'][61] = 0;
  _$jscoverage['mediator.js'][64] = 0;
  _$jscoverage['mediator.js'][70] = 0;
  _$jscoverage['mediator.js'][71] = 0;
  _$jscoverage['mediator.js'][72] = 0;
  _$jscoverage['mediator.js'][73] = 0;
  _$jscoverage['mediator.js'][74] = 0;
  _$jscoverage['mediator.js'][75] = 0;
  _$jscoverage['mediator.js'][82] = 0;
  _$jscoverage['mediator.js'][83] = 0;
  _$jscoverage['mediator.js'][84] = 0;
  _$jscoverage['mediator.js'][87] = 0;
  _$jscoverage['mediator.js'][88] = 0;
  _$jscoverage['mediator.js'][89] = 0;
  _$jscoverage['mediator.js'][90] = 0;
  _$jscoverage['mediator.js'][91] = 0;
  _$jscoverage['mediator.js'][100] = 0;
  _$jscoverage['mediator.js'][102] = 0;
  _$jscoverage['mediator.js'][104] = 0;
  _$jscoverage['mediator.js'][108] = 0;
  _$jscoverage['mediator.js'][110] = 0;
  _$jscoverage['mediator.js'][111] = 0;
  _$jscoverage['mediator.js'][113] = 0;
  _$jscoverage['mediator.js'][115] = 0;
  _$jscoverage['mediator.js'][118] = 0;
  _$jscoverage['mediator.js'][120] = 0;
  _$jscoverage['mediator.js'][127] = 0;
  _$jscoverage['mediator.js'][131] = 0;
  _$jscoverage['mediator.js'][134] = 0;
  _$jscoverage['mediator.js'][135] = 0;
  _$jscoverage['mediator.js'][136] = 0;
  _$jscoverage['mediator.js'][146] = 0;
  _$jscoverage['mediator.js'][150] = 0;
  _$jscoverage['mediator.js'][151] = 0;
  _$jscoverage['mediator.js'][152] = 0;
  _$jscoverage['mediator.js'][154] = 0;
  _$jscoverage['mediator.js'][157] = 0;
  _$jscoverage['mediator.js'][158] = 0;
  _$jscoverage['mediator.js'][159] = 0;
  _$jscoverage['mediator.js'][161] = 0;
  _$jscoverage['mediator.js'][162] = 0;
  _$jscoverage['mediator.js'][166] = 0;
  _$jscoverage['mediator.js'][170] = 0;
  _$jscoverage['mediator.js'][174] = 0;
  _$jscoverage['mediator.js'][178] = 0;
  _$jscoverage['mediator.js'][180] = 0;
  _$jscoverage['mediator.js'][183] = 0;
  _$jscoverage['mediator.js'][184] = 0;
  _$jscoverage['mediator.js'][185] = 0;
  _$jscoverage['mediator.js'][189] = 0;
  _$jscoverage['mediator.js'][190] = 0;
  _$jscoverage['mediator.js'][191] = 0;
  _$jscoverage['mediator.js'][192] = 0;
  _$jscoverage['mediator.js'][201] = 0;
  _$jscoverage['mediator.js'][207] = 0;
  _$jscoverage['mediator.js'][208] = 0;
  _$jscoverage['mediator.js'][209] = 0;
  _$jscoverage['mediator.js'][210] = 0;
  _$jscoverage['mediator.js'][211] = 0;
  _$jscoverage['mediator.js'][212] = 0;
  _$jscoverage['mediator.js'][213] = 0;
  _$jscoverage['mediator.js'][216] = 0;
  _$jscoverage['mediator.js'][217] = 0;
  _$jscoverage['mediator.js'][221] = 0;
  _$jscoverage['mediator.js'][222] = 0;
  _$jscoverage['mediator.js'][224] = 0;
  _$jscoverage['mediator.js'][225] = 0;
  _$jscoverage['mediator.js'][227] = 0;
  _$jscoverage['mediator.js'][232] = 0;
  _$jscoverage['mediator.js'][233] = 0;
  _$jscoverage['mediator.js'][236] = 0;
  _$jscoverage['mediator.js'][240] = 0;
  _$jscoverage['mediator.js'][241] = 0;
  _$jscoverage['mediator.js'][242] = 0;
  _$jscoverage['mediator.js'][245] = 0;
  _$jscoverage['mediator.js'][251] = 0;
  _$jscoverage['mediator.js'][257] = 0;
  _$jscoverage['mediator.js'][262] = 0;
  _$jscoverage['mediator.js'][263] = 0;
  _$jscoverage['mediator.js'][266] = 0;
  _$jscoverage['mediator.js'][267] = 0;
  _$jscoverage['mediator.js'][269] = 0;
  _$jscoverage['mediator.js'][270] = 0;
  _$jscoverage['mediator.js'][273] = 0;
  _$jscoverage['mediator.js'][277] = 0;
  _$jscoverage['mediator.js'][287] = 0;
  _$jscoverage['mediator.js'][289] = 0;
  _$jscoverage['mediator.js'][290] = 0;
  _$jscoverage['mediator.js'][292] = 0;
  _$jscoverage['mediator.js'][302] = 0;
  _$jscoverage['mediator.js'][303] = 0;
  _$jscoverage['mediator.js'][305] = 0;
  _$jscoverage['mediator.js'][312] = 0;
  _$jscoverage['mediator.js'][319] = 0;
  _$jscoverage['mediator.js'][328] = 0;
  _$jscoverage['mediator.js'][331] = 0;
  _$jscoverage['mediator.js'][333] = 0;
  _$jscoverage['mediator.js'][338] = 0;
  _$jscoverage['mediator.js'][339] = 0;
  _$jscoverage['mediator.js'][340] = 0;
  _$jscoverage['mediator.js'][341] = 0;
  _$jscoverage['mediator.js'][342] = 0;
  _$jscoverage['mediator.js'][346] = 0;
  _$jscoverage['mediator.js'][347] = 0;
  _$jscoverage['mediator.js'][348] = 0;
}
_$jscoverage['mediator.js'].source = ["/*jslint bitwise: true, nomen: true, plusplus: true, white: true */","","/*!","* Mediator.js Library v0.9.0","* https://github.com/ajacksified/Mediator.js","*","* Copyright 2013, Jack Lawson","* MIT Licensed (http://www.opensource.org/licenses/mit-license.php)","*","* For more information: http://thejacklawson.com/2011/06/mediators-for-modularized-asynchronous-programming-in-javascript/index.html","* Project on GitHub: https://github.com/ajacksified/Mediator.js","*","* Last update: Jan 04 2013","*/","","(function(root, factory) {","  'use strict';","","  if(typeof root.exports === 'function') {","    // Node/CommonJS","    root.exports.Mediator = factory();","  } else if(typeof root.define === 'function' &amp;&amp; root.define.amd) {","    // AMD","    root.define([], function() {","      // Export to global too, for backward compatiblity","      root.Mediator = factory();","    });","  } else {","    // Browser global","    root.Mediator = factory();","  }","}(this, function() {","  'use strict';","","  // We'll generate guids for class instances for easy referencing later on.","  // Subscriber instances will have an id that can be refernced for quick","  // lookups.","","  function guidGenerator() {","    var S4 = function() {","       return (((1+Math.random())*0x10000)|0).toString(16).substring(1);","    };","","    return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());","  }","","  // Subscribers are instances of Mediator Channel registrations. We generate","  // an object instance so that it can be updated later on without having to","  // unregister and re-register. Subscribers are constructed with a function","  // to be called, options object, and context.","","  function Subscriber(fn, options, context){","    if(!(this instanceof Subscriber)) {","      return new Subscriber(fn, options, context);","    }","","    this.id = guidGenerator();","    this.fn = fn;","    this.options = options;","    this.context = context;","    this.channel = null;","  }","","  Subscriber.prototype = {","    // Mediator.update on a subscriber instance can update its function,context,","    // or options object. It takes in an object and looks for fn, context, or","    // options keys.","","    update: function(options){","      if(options){","        this.fn = options.fn || this.fn;","        this.context = options.context || this.context;","        this.options = options.options || this.options;","        if(this.channel &amp;&amp; this.options &amp;&amp; this.options.priority !== undefined) {","            this.channel.setPriority(this.id, this.options.priority);","        }","      }","    }","  };","","","  function Channel(namespace, parent){","    if(!(this instanceof Channel)) {","      return new Channel(namespace);","    }","","    this.namespace = namespace || \"\";","    this._subscribers = [];","    this._channels = [];","    this._parent = parent;","    this.stopped = false;","  }","","  // A Mediator channel holds a list of sub-channels and subscribers to be fired","  // when Mediator.publish is called on the Mediator instance. It also contains","  // some methods to manipulate its lists of data; only setPriority and","  // StopPropagation are meant to be used. The other methods should be accessed","  // through the Mediator instance.","","  Channel.prototype = {","    addSubscriber: function(fn, options, context){","      var subscriber = new Subscriber(fn, options, context);","","      if(options &amp;&amp; options.priority !== undefined){","        // Cheap hack to either parse as an int or turn it into 0. Runs faster","        // in many browsers than parseInt with the benefit that it won't","        // return a NaN.","        options.priority = options.priority &gt;&gt; 0;","","        if(options.priority &lt; 0){ options.priority = 0; }","        if(options.priority &gt;= this._subscribers.length){ options.priority = this._subscribers.length-1; }","","        this._subscribers.splice(options.priority, 0, subscriber);","      }else{","        this._subscribers.push(subscriber);","      }","","      subscriber.channel = this;","","      return subscriber;","    },","","    // The channel instance is passed as an argument to the mediator subscriber,","    // and further subscriber propagation can be called with","    // channel.StopPropagation().","    stopPropagation: function(){","      this.stopped = true;","    },","","    getSubscriber: function(identifier){","      var x = 0,","          y = this._subscribers.length;","","      for(x, y; x &lt; y; x++){","        if(this._subscribers[x].id === identifier || this._subscribers[x].fn === identifier){","          return this._subscribers[x];","        }","      }","    },","","    // Channel.setPriority is useful in updating the order in which Subscribers","    // are called, and takes an identifier (subscriber id or named function) and","    // an array index. It will not search recursively through subchannels.","","    setPriority: function(identifier, priority){","      var oldIndex = 0,","          x = 0,","          sub, firstHalf, lastHalf, y;","","      for(x = 0, y = this._subscribers.length; x &lt; y; x++){","        if(this._subscribers[x].id === identifier || this._subscribers[x].fn === identifier){","          break;","        }","        oldIndex ++;","      }","","      sub = this._subscribers[oldIndex];","      firstHalf = this._subscribers.slice(0, oldIndex);","      lastHalf = this._subscribers.slice(oldIndex+1);","","      this._subscribers = firstHalf.concat(lastHalf);","      this._subscribers.splice(priority, 0, sub);","    },","","    addChannel: function(channel){","      this._channels[channel] = new Channel((this.namespace ? this.namespace + ':' : '') + channel, this);","    },","","    hasChannel: function(channel){","      return this._channels.hasOwnProperty(channel);","    },","","    returnChannel: function(channel){","      return this._channels[channel];","    },","","    removeSubscriber: function(identifier){","      var x = 0,","          y;","          y = this._subscribers.length;","","      // If we don't pass in an id, we're clearing all","      if(!identifier){","        this._subscribers = [];","        return;","      }","","      // Going backwards makes splicing a whole lot easier.","      for(x, y; y &gt; x; y--) {","        if(this._subscribers[x].fn === identifier || this._subscribers[x].id === identifier){","          this._subscribers[x].channel = null;","          this._subscribers.splice(x,1);","        }","      }","    },","","    // This will publish arbitrary arguments to a subscriber and then to parent","    // channels.","","    publish: function(data){","      var x = 0,","          y = this._subscribers.length,","          called = false,","          subscriber, l;","","      // Priority is preserved in the _subscribers index.","      for(x, y; x &lt; y; x++) {","        if(!this.stopped){","          subscriber = this._subscribers[x];","          if(subscriber.options !== undefined &amp;&amp; typeof subscriber.options.predicate === \"function\"){","            if(subscriber.options.predicate.apply(subscriber.context, data)){","              subscriber.fn.apply(subscriber.context, data);","              called = true;","            }","          }else{","            subscriber.fn.apply(subscriber.context, data);","            called = true;","          }","        }","","        if(called &amp;&amp; subscriber.options &amp;&amp; subscriber.options !== undefined){","          subscriber.options.calls--;","","          if(subscriber.options.calls &lt; 1){","            this.removeSubscriber(subscriber.id);","          }else{","            subscriber.update(subscriber.options);","          }","        }","      }","","      if(this._parent){","        this._parent.publish(data);","      }","","      this.stopped = false;","    }","  };","","  function Mediator() {","    if(!(this instanceof Mediator)) {","      return new Mediator();","    }","","    this._channels = new Channel('');","  }","","  // A Mediator instance is the interface through which events are registered","  // and removed from publish channels.","","  Mediator.prototype = {","","    // Returns a channel instance based on namespace, for example","    // application:chat:message:received","","    getChannel: function(namespace){","      var channel = this._channels,","          namespaceHierarchy = namespace.split(':'),","          x = 0, ","          y = namespaceHierarchy.length;","","      if(namespace === ''){","        return channel;","      }","","      if(namespaceHierarchy.length &gt; 0){","        for(x, y; x &lt; y; x++){","","          if(!channel.hasChannel(namespaceHierarchy[x])){","            channel.addChannel(namespaceHierarchy[x]);","          }","","          channel = channel.returnChannel(namespaceHierarchy[x]);","        }","      }","","      return channel;","    },","","    // Pass in a channel namespace, function to be called, options, and context","    // to call the function in to Subscribe. It will create a channel if one","    // does not exist. Options can include a predicate to determine if it","    // should be called (based on the data published to it) and a priority","    // index.","","    subscribe: function(channelName, fn, options, context){","      var channel = this.getChannel(channelName);","","      options = options || {};","      context = context || {};","","      return channel.addSubscriber(fn, options, context);","    },","","    // Pass in a channel namespace, function to be called, options, and context","    // to call the function in to Subscribe. It will create a channel if one","    // does not exist. Options can include a predicate to determine if it","    // should be called (based on the data published to it) and a priority","    // index.","","    once: function(channelName, fn, options, context){","      options = options || {};","      options.calls = 1;","","      return this.subscribe(channelName, fn, options, context);","    },","","    // Returns a subscriber for a given subscriber id / named function and","    // channel namespace","","    getSubscriber: function(identifier, channel){","      return this.getChannel(channel || \"\").getSubscriber(identifier);","    },","","    // Remove a subscriber from a given channel namespace recursively based on","    // a passed-in subscriber id or named function.","","    remove: function(channelName, identifier){","      this.getChannel(channelName).removeSubscriber(identifier);","    },","","    // Publishes arbitrary data to a given channel namespace. Channels are","    // called recursively downwards; a post to application:chat will post to","    // application:chat:receive and application:chat:derp:test:beta:bananas.","    // Called using Mediator.publish(\"application:chat\", [ args ]);","","    publish: function(channelName){","      var args = Array.prototype.slice.call(arguments, 1),","          channel = this.getChannel(channelName);","","      args.push(channel);","","      this.getChannel(channelName).publish(args);","    }","  };","","  // Alias some common names for easy interop","  Mediator.prototype.on = Mediator.prototype.subscribe;","  Mediator.prototype.bind = Mediator.prototype.subscribe;","  Mediator.prototype.emit = Mediator.prototype.publish;","  Mediator.prototype.trigger = Mediator.prototype.publish;","  Mediator.prototype.off = Mediator.prototype.remove;","","  // Finally, expose it all.","","  Mediator.Channel = Channel;","  Mediator.Subscriber = Subscriber;","  return Mediator;","}));"];
_$jscoverage['mediator.js'][16]++;
(function (root, factory) {
  _$jscoverage['mediator.js'][17]++;
  "use strict";
  _$jscoverage['mediator.js'][19]++;
  if (((typeof root.exports) === "function")) {
    _$jscoverage['mediator.js'][21]++;
    root.exports.Mediator = factory();
  }
  else {
    _$jscoverage['mediator.js'][22]++;
    if ((((typeof root.define) === "function") && root.define.amd)) {
      _$jscoverage['mediator.js'][24]++;
      root.define([], (function () {
  _$jscoverage['mediator.js'][26]++;
  root.Mediator = factory();
}));
    }
    else {
      _$jscoverage['mediator.js'][30]++;
      root.Mediator = factory();
    }
  }
})(this, (function () {
  _$jscoverage['mediator.js'][33]++;
  "use strict";
  _$jscoverage['mediator.js'][39]++;
  function guidGenerator() {
    _$jscoverage['mediator.js'][40]++;
    var S4 = (function () {
  _$jscoverage['mediator.js'][41]++;
  return (((1 + Math.random()) * 65536) | 0).toString(16).substring(1);
});
    _$jscoverage['mediator.js'][44]++;
    return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
}
  _$jscoverage['mediator.js'][52]++;
  function Subscriber(fn, options, context) {
    _$jscoverage['mediator.js'][53]++;
    if ((! (this instanceof Subscriber))) {
      _$jscoverage['mediator.js'][54]++;
      return new Subscriber(fn, options, context);
    }
    _$jscoverage['mediator.js'][57]++;
    this.id = guidGenerator();
    _$jscoverage['mediator.js'][58]++;
    this.fn = fn;
    _$jscoverage['mediator.js'][59]++;
    this.options = options;
    _$jscoverage['mediator.js'][60]++;
    this.context = context;
    _$jscoverage['mediator.js'][61]++;
    this.channel = null;
}
  _$jscoverage['mediator.js'][64]++;
  Subscriber.prototype = {update: (function (options) {
  _$jscoverage['mediator.js'][70]++;
  if (options) {
    _$jscoverage['mediator.js'][71]++;
    this.fn = (options.fn || this.fn);
    _$jscoverage['mediator.js'][72]++;
    this.context = (options.context || this.context);
    _$jscoverage['mediator.js'][73]++;
    this.options = (options.options || this.options);
    _$jscoverage['mediator.js'][74]++;
    if ((this.channel && this.options && (this.options.priority !== undefined))) {
      _$jscoverage['mediator.js'][75]++;
      this.channel.setPriority(this.id, this.options.priority);
    }
  }
})};
  _$jscoverage['mediator.js'][82]++;
  function Channel(namespace, parent) {
    _$jscoverage['mediator.js'][83]++;
    if ((! (this instanceof Channel))) {
      _$jscoverage['mediator.js'][84]++;
      return new Channel(namespace);
    }
    _$jscoverage['mediator.js'][87]++;
    this.namespace = (namespace || "");
    _$jscoverage['mediator.js'][88]++;
    this._subscribers = [];
    _$jscoverage['mediator.js'][89]++;
    this._channels = [];
    _$jscoverage['mediator.js'][90]++;
    this._parent = parent;
    _$jscoverage['mediator.js'][91]++;
    this.stopped = false;
}
  _$jscoverage['mediator.js'][100]++;
  Channel.prototype = {addSubscriber: (function (fn, options, context) {
  _$jscoverage['mediator.js'][102]++;
  var subscriber = new Subscriber(fn, options, context);
  _$jscoverage['mediator.js'][104]++;
  if ((options && (options.priority !== undefined))) {
    _$jscoverage['mediator.js'][108]++;
    options.priority = (options.priority >> 0);
    _$jscoverage['mediator.js'][110]++;
    if ((options.priority < 0)) {
      _$jscoverage['mediator.js'][110]++;
      options.priority = 0;
    }
    _$jscoverage['mediator.js'][111]++;
    if ((options.priority >= this._subscribers.length)) {
      _$jscoverage['mediator.js'][111]++;
      options.priority = (this._subscribers.length - 1);
    }
    _$jscoverage['mediator.js'][113]++;
    this._subscribers.splice(options.priority, 0, subscriber);
  }
  else {
    _$jscoverage['mediator.js'][115]++;
    this._subscribers.push(subscriber);
  }
  _$jscoverage['mediator.js'][118]++;
  subscriber.channel = this;
  _$jscoverage['mediator.js'][120]++;
  return subscriber;
}), stopPropagation: (function () {
  _$jscoverage['mediator.js'][127]++;
  this.stopped = true;
}), getSubscriber: (function (identifier) {
  _$jscoverage['mediator.js'][131]++;
  var x = 0, y = this._subscribers.length;
  _$jscoverage['mediator.js'][134]++;
  for ((x, y); (x < y); (x++)) {
    _$jscoverage['mediator.js'][135]++;
    if (((this._subscribers[x].id === identifier) || (this._subscribers[x].fn === identifier))) {
      _$jscoverage['mediator.js'][136]++;
      return this._subscribers[x];
    }
}
}), setPriority: (function (identifier, priority) {
  _$jscoverage['mediator.js'][146]++;
  var oldIndex = 0, x = 0, sub, firstHalf, lastHalf, y;
  _$jscoverage['mediator.js'][150]++;
  for (((x = 0), (y = this._subscribers.length)); (x < y); (x++)) {
    _$jscoverage['mediator.js'][151]++;
    if (((this._subscribers[x].id === identifier) || (this._subscribers[x].fn === identifier))) {
      _$jscoverage['mediator.js'][152]++;
      break;
    }
    _$jscoverage['mediator.js'][154]++;
    (oldIndex++);
}
  _$jscoverage['mediator.js'][157]++;
  sub = this._subscribers[oldIndex];
  _$jscoverage['mediator.js'][158]++;
  firstHalf = this._subscribers.slice(0, oldIndex);
  _$jscoverage['mediator.js'][159]++;
  lastHalf = this._subscribers.slice((oldIndex + 1));
  _$jscoverage['mediator.js'][161]++;
  this._subscribers = firstHalf.concat(lastHalf);
  _$jscoverage['mediator.js'][162]++;
  this._subscribers.splice(priority, 0, sub);
}), addChannel: (function (channel) {
  _$jscoverage['mediator.js'][166]++;
  this._channels[channel] = new Channel(((this.namespace? (this.namespace + ":"): "") + channel), this);
}), hasChannel: (function (channel) {
  _$jscoverage['mediator.js'][170]++;
  return this._channels.hasOwnProperty(channel);
}), returnChannel: (function (channel) {
  _$jscoverage['mediator.js'][174]++;
  return this._channels[channel];
}), removeSubscriber: (function (identifier) {
  _$jscoverage['mediator.js'][178]++;
  var x = 0, y;
  _$jscoverage['mediator.js'][180]++;
  y = this._subscribers.length;
  _$jscoverage['mediator.js'][183]++;
  if ((! identifier)) {
    _$jscoverage['mediator.js'][184]++;
    this._subscribers = [];
    _$jscoverage['mediator.js'][185]++;
    return;
  }
  _$jscoverage['mediator.js'][189]++;
  for ((x, y); (y > x); (y--)) {
    _$jscoverage['mediator.js'][190]++;
    if (((this._subscribers[x].fn === identifier) || (this._subscribers[x].id === identifier))) {
      _$jscoverage['mediator.js'][191]++;
      this._subscribers[x].channel = null;
      _$jscoverage['mediator.js'][192]++;
      this._subscribers.splice(x, 1);
    }
}
}), publish: (function (data) {
  _$jscoverage['mediator.js'][201]++;
  var x = 0, y = this._subscribers.length, called = false, subscriber, l;
  _$jscoverage['mediator.js'][207]++;
  for ((x, y); (x < y); (x++)) {
    _$jscoverage['mediator.js'][208]++;
    if ((! this.stopped)) {
      _$jscoverage['mediator.js'][209]++;
      subscriber = this._subscribers[x];
      _$jscoverage['mediator.js'][210]++;
      if (((subscriber.options !== undefined) && ((typeof subscriber.options.predicate) === "function"))) {
        _$jscoverage['mediator.js'][211]++;
        if (subscriber.options.predicate.apply(subscriber.context, data)) {
          _$jscoverage['mediator.js'][212]++;
          subscriber.fn.apply(subscriber.context, data);
          _$jscoverage['mediator.js'][213]++;
          called = true;
        }
      }
      else {
        _$jscoverage['mediator.js'][216]++;
        subscriber.fn.apply(subscriber.context, data);
        _$jscoverage['mediator.js'][217]++;
        called = true;
      }
    }
    _$jscoverage['mediator.js'][221]++;
    if ((called && subscriber.options && (subscriber.options !== undefined))) {
      _$jscoverage['mediator.js'][222]++;
      (subscriber.options.calls--);
      _$jscoverage['mediator.js'][224]++;
      if ((subscriber.options.calls < 1)) {
        _$jscoverage['mediator.js'][225]++;
        this.removeSubscriber(subscriber.id);
      }
      else {
        _$jscoverage['mediator.js'][227]++;
        subscriber.update(subscriber.options);
      }
    }
}
  _$jscoverage['mediator.js'][232]++;
  if (this._parent) {
    _$jscoverage['mediator.js'][233]++;
    this._parent.publish(data);
  }
  _$jscoverage['mediator.js'][236]++;
  this.stopped = false;
})};
  _$jscoverage['mediator.js'][240]++;
  function Mediator() {
    _$jscoverage['mediator.js'][241]++;
    if ((! (this instanceof Mediator))) {
      _$jscoverage['mediator.js'][242]++;
      return new Mediator();
    }
    _$jscoverage['mediator.js'][245]++;
    this._channels = new Channel("");
}
  _$jscoverage['mediator.js'][251]++;
  Mediator.prototype = {getChannel: (function (namespace) {
  _$jscoverage['mediator.js'][257]++;
  var channel = this._channels, namespaceHierarchy = namespace.split(":"), x = 0, y = namespaceHierarchy.length;
  _$jscoverage['mediator.js'][262]++;
  if ((namespace === "")) {
    _$jscoverage['mediator.js'][263]++;
    return channel;
  }
  _$jscoverage['mediator.js'][266]++;
  if ((namespaceHierarchy.length > 0)) {
    _$jscoverage['mediator.js'][267]++;
    for ((x, y); (x < y); (x++)) {
      _$jscoverage['mediator.js'][269]++;
      if ((! channel.hasChannel(namespaceHierarchy[x]))) {
        _$jscoverage['mediator.js'][270]++;
        channel.addChannel(namespaceHierarchy[x]);
      }
      _$jscoverage['mediator.js'][273]++;
      channel = channel.returnChannel(namespaceHierarchy[x]);
}
  }
  _$jscoverage['mediator.js'][277]++;
  return channel;
}), subscribe: (function (channelName, fn, options, context) {
  _$jscoverage['mediator.js'][287]++;
  var channel = this.getChannel(channelName);
  _$jscoverage['mediator.js'][289]++;
  options = (options || {});
  _$jscoverage['mediator.js'][290]++;
  context = (context || {});
  _$jscoverage['mediator.js'][292]++;
  return channel.addSubscriber(fn, options, context);
}), once: (function (channelName, fn, options, context) {
  _$jscoverage['mediator.js'][302]++;
  options = (options || {});
  _$jscoverage['mediator.js'][303]++;
  options.calls = 1;
  _$jscoverage['mediator.js'][305]++;
  return this.subscribe(channelName, fn, options, context);
}), getSubscriber: (function (identifier, channel) {
  _$jscoverage['mediator.js'][312]++;
  return this.getChannel((channel || "")).getSubscriber(identifier);
}), remove: (function (channelName, identifier) {
  _$jscoverage['mediator.js'][319]++;
  this.getChannel(channelName).removeSubscriber(identifier);
}), publish: (function (channelName) {
  _$jscoverage['mediator.js'][328]++;
  var args = Array.prototype.slice.call(arguments, 1), channel = this.getChannel(channelName);
  _$jscoverage['mediator.js'][331]++;
  args.push(channel);
  _$jscoverage['mediator.js'][333]++;
  this.getChannel(channelName).publish(args);
})};
  _$jscoverage['mediator.js'][338]++;
  Mediator.prototype.on = Mediator.prototype.subscribe;
  _$jscoverage['mediator.js'][339]++;
  Mediator.prototype.bind = Mediator.prototype.subscribe;
  _$jscoverage['mediator.js'][340]++;
  Mediator.prototype.emit = Mediator.prototype.publish;
  _$jscoverage['mediator.js'][341]++;
  Mediator.prototype.trigger = Mediator.prototype.publish;
  _$jscoverage['mediator.js'][342]++;
  Mediator.prototype.off = Mediator.prototype.remove;
  _$jscoverage['mediator.js'][346]++;
  Mediator.Channel = Channel;
  _$jscoverage['mediator.js'][347]++;
  Mediator.Subscriber = Subscriber;
  _$jscoverage['mediator.js'][348]++;
  return Mediator;
}));

},{}],4:[function(require,module,exports){
/*jslint bitwise: true, nomen: true, plusplus: true, white: true */

/*!
* Mediator.js Library v0.9.8
* https://github.com/ajacksified/Mediator.js
*
* Copyright 2013, Jack Lawson
* MIT Licensed (http://www.opensource.org/licenses/mit-license.php)
*
* For more information: http://thejacklawson.com/2011/06/mediators-for-modularized-asynchronous-programming-in-javascript/index.html
* Project on GitHub: https://github.com/ajacksified/Mediator.js
*
* Last update: October 19 2013
*/

(function(global, factory) {
  'use strict';

  if (typeof define === 'function' && define.amd) {
    // AMD
    define('mediator-js', [], function() {
      global.Mediator = factory();
      return global.Mediator;
    });
  } else if (typeof exports !== 'undefined') {
    // Node/CommonJS
    exports.Mediator = factory();
  } else {
    // Browser global
    global.Mediator = factory();
  }
}(this, function() {
  'use strict';

  // We'll generate guids for class instances for easy referencing later on.
  // Subscriber instances will have an id that can be refernced for quick
  // lookups.

  function guidGenerator() {
    var S4 = function() {
       return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    };

    return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
  }

  // Subscribers are instances of Mediator Channel registrations. We generate
  // an object instance so that it can be updated later on without having to
  // unregister and re-register. Subscribers are constructed with a function
  // to be called, options object, and context.

  function Subscriber(fn, options, context) {
    if (!(this instanceof Subscriber)) {
      return new Subscriber(fn, options, context);
    }

    this.id = guidGenerator();
    this.fn = fn;
    this.options = options;
    this.context = context;
    this.channel = null;
  }

  // Mediator.update on a subscriber instance can update its function,context,
  // or options object. It takes in an object and looks for fn, context, or
  // options keys.
  Subscriber.prototype.update = function(options) {
    if (options) {
      this.fn = options.fn || this.fn;
      this.context = options.context || this.context;
      this.options = options.options || this.options;
      if (this.channel && this.options && this.options.priority !== undefined) {
          this.channel.setPriority(this.id, this.options.priority);
      }
    }
  }


  function Channel(namespace, parent) {
    if (!(this instanceof Channel)) {
      return new Channel(namespace);
    }

    this.namespace = namespace || "";
    this._subscribers = [];
    this._channels = {};
    this._parent = parent;
    this.stopped = false;
  }

  // A Mediator channel holds a list of sub-channels and subscribers to be fired
  // when Mediator.publish is called on the Mediator instance. It also contains
  // some methods to manipulate its lists of data; only setPriority and
  // StopPropagation are meant to be used. The other methods should be accessed
  // through the Mediator instance.
  Channel.prototype.addSubscriber = function(fn, options, context) {
    var subscriber = new Subscriber(fn, options, context);

    if (options && options.priority !== undefined) {
      // Cheap hack to either parse as an int or turn it into 0. Runs faster
      // in many browsers than parseInt with the benefit that it won't
      // return a NaN.
      options.priority = options.priority >> 0;

      if (options.priority < 0) { options.priority = 0; }
      if (options.priority >= this._subscribers.length) { options.priority = this._subscribers.length-1; }

      this._subscribers.splice(options.priority, 0, subscriber);
    }else{
      this._subscribers.push(subscriber);
    }

    subscriber.channel = this;

    return subscriber;
  }

  // The channel instance is passed as an argument to the mediator subscriber,
  // and further subscriber propagation can be called with
  // channel.StopPropagation().
  Channel.prototype.stopPropagation = function() {
    this.stopped = true;
  }

  Channel.prototype.getSubscriber = function(identifier) {
    var x = 0,
        y = this._subscribers.length;

    for(x, y; x < y; x++) {
      if (this._subscribers[x].id === identifier || this._subscribers[x].fn === identifier) {
        return this._subscribers[x];
      }
    }
  }

  // Channel.setPriority is useful in updating the order in which Subscribers
  // are called, and takes an identifier (subscriber id or named function) and
  // an array index. It will not search recursively through subchannels.

  Channel.prototype.setPriority = function(identifier, priority) {
    var oldIndex = 0,
        x = 0,
        sub, firstHalf, lastHalf, y;

    for(x = 0, y = this._subscribers.length; x < y; x++) {
      if (this._subscribers[x].id === identifier || this._subscribers[x].fn === identifier) {
        break;
      }
      oldIndex ++;
    }

    sub = this._subscribers[oldIndex];
    firstHalf = this._subscribers.slice(0, oldIndex);
    lastHalf = this._subscribers.slice(oldIndex+1);

    this._subscribers = firstHalf.concat(lastHalf);
    this._subscribers.splice(priority, 0, sub);
  }

  Channel.prototype.addChannel = function(channel) {
    this._channels[channel] = new Channel((this.namespace ? this.namespace + ':' : '') + channel, this);
  }

  Channel.prototype.hasChannel = function(channel) {
    return this._channels.hasOwnProperty(channel);
  }

  Channel.prototype.returnChannel = function(channel) {
    return this._channels[channel];
  }

  Channel.prototype.removeSubscriber = function(identifier) {
    var x = this._subscribers.length - 1;

    // If we don't pass in an id, we're clearing all
    if (!identifier) {
      this._subscribers = [];
      return;
    }

    // Going backwards makes splicing a whole lot easier.
    for(x; x >= 0; x--) {
      if (this._subscribers[x].fn === identifier || this._subscribers[x].id === identifier) {
        this._subscribers[x].channel = null;
        this._subscribers.splice(x,1);
      }
    }
  }

    // This will publish arbitrary arguments to a subscriber and then to parent
    // channels.

  Channel.prototype.publish = function(data) {
    var x = 0,
        y = this._subscribers.length,
        shouldCall = false,
        subscriber, l,
        subsBefore,subsAfter;

    // Priority is preserved in the _subscribers index.
    for(x, y; x < y; x++) {
      // By default set the flag to false
      shouldCall = false;
      subscriber = this._subscribers[x];

      if (!this.stopped) {
        subsBefore = this._subscribers.length;
        if (subscriber.options !== undefined && typeof subscriber.options.predicate === "function") {
          if (subscriber.options.predicate.apply(subscriber.context, data)) {
            // The predicate matches, the callback function should be called
            shouldCall = true;
          }
        }else{
          // There is no predicate to match, the callback should always be called
          shouldCall = true;
        }
      }

      // Check if the callback should be called
      if (shouldCall) {
        // Check if the subscriber has options and if this include the calls options
        if (subscriber.options && subscriber.options.calls !== undefined) {
          // Decrease the number of calls left by one
          subscriber.options.calls--;
          // Once the number of calls left reaches zero or less we need to remove the subscriber
          if (subscriber.options.calls < 1) {
            this.removeSubscriber(subscriber.id);
          }
        }
        // Now we call the callback, if this in turns publishes to the same channel it will no longer
        // cause the callback to be called as we just removed it as a subscriber
        subscriber.fn.apply(subscriber.context, data);

        subsAfter = this._subscribers.length;
        y = subsAfter;
        if (subsAfter === subsBefore - 1) {
          x--;
        }
      }
    }

    if (this._parent) {
      this._parent.publish(data);
    }

    this.stopped = false;
  }

  function Mediator() {
    if (!(this instanceof Mediator)) {
      return new Mediator();
    }

    this._channels = new Channel('');
  }

  // A Mediator instance is the interface through which events are registered
  // and removed from publish channels.

  // Returns a channel instance based on namespace, for example
  // application:chat:message:received. If readOnly is true we
  // will refrain from creating non existing channels.
  Mediator.prototype.getChannel = function(namespace, readOnly) {
    var channel = this._channels,
        namespaceHierarchy = namespace.split(':'),
        x = 0,
        y = namespaceHierarchy.length;

    if (namespace === '') {
      return channel;
    }

    if (namespaceHierarchy.length > 0) {
      for(x, y; x < y; x++) {

        if (!channel.hasChannel(namespaceHierarchy[x])) {
          if (readOnly) {
            break;
          } else {
            channel.addChannel(namespaceHierarchy[x]);
          }
        }

        channel = channel.returnChannel(namespaceHierarchy[x]);
      }
    }

    return channel;
  }

  // Pass in a channel namespace, function to be called, options, and context
  // to call the function in to Subscribe. It will create a channel if one
  // does not exist. Options can include a predicate to determine if it
  // should be called (based on the data published to it) and a priority
  // index.

  Mediator.prototype.subscribe = function(channelName, fn, options, context) {
    var channel = this.getChannel(channelName || "", false);

    options = options || {};
    context = context || {};

    return channel.addSubscriber(fn, options, context);
  }

  // Pass in a channel namespace, function to be called, options, and context
  // to call the function in to Subscribe. It will create a channel if one
  // does not exist. Options can include a predicate to determine if it
  // should be called (based on the data published to it) and a priority
  // index.

  Mediator.prototype.once = function(channelName, fn, options, context) {
    options = options || {};
    options.calls = 1;

    return this.subscribe(channelName, fn, options, context);
  }

  // Returns a subscriber for a given subscriber id / named function and
  // channel namespace

  Mediator.prototype.getSubscriber = function(identifier, channelName) {
    var channel = this.getChannel(channelName || "", true);
    // We have to check if channel within the hierarchy exists and if it is
    // an exact match for the requested channel
    if (channel.namespace !== channelName) {
      return null;
    }

    return channel.getSubscriber(identifier);
  }

  // Remove a subscriber from a given channel namespace recursively based on
  // a passed-in subscriber id or named function.

  Mediator.prototype.remove = function(channelName, identifier) {
    var channel = this.getChannel(channelName || "", true);
    if (channel.namespace !== channelName) {
      return false;
    }

    channel.removeSubscriber(identifier);
  }

  // Publishes arbitrary data to a given channel namespace. Channels are
  // called recursively downwards; a post to application:chat will post to
  // application:chat:receive and application:chat:derp:test:beta:bananas.
  // Called using Mediator.publish("application:chat", [ args ]);

  Mediator.prototype.publish = function(channelName) {
    var channel = this.getChannel(channelName || "", true);
    if (channel.namespace !== channelName) {
      return null;
    }

    var args = Array.prototype.slice.call(arguments, 1);

    args.push(channel);

    channel.publish(args);
  }

  // Alias some common names for easy interop
  Mediator.prototype.on = Mediator.prototype.subscribe;
  Mediator.prototype.bind = Mediator.prototype.subscribe;
  Mediator.prototype.emit = Mediator.prototype.publish;
  Mediator.prototype.trigger = Mediator.prototype.publish;
  Mediator.prototype.off = Mediator.prototype.remove;

  // Finally, expose it all.

  Mediator.Channel = Channel;
  Mediator.Subscriber = Subscriber;
  Mediator.version = "0.9.8";

  return Mediator;
}));

},{}],5:[function(require,module,exports){
/* global window, require, App */

// intro credits displayed in the browser console
require('./introCredits.js');

(function () {

	"use strict";

	// the global App property
	window.App = window.App || {};

	// set the main container property to the app object
	App.container = document.querySelector('.ns-clv4');

	// load the config object
	var config = require('./config.js');

	// place the config object into the App
	App.config = config;

	var Helpers = require('./helpers.js');
	var Globals = require('./globals.js');

	// set the helper obj to the App
	App.helpers = new Helpers();

	// load components
	require('./components/all.js');

	// load event management library (implement the mediator pattern)
	var Mediator = require( 'mediator-js' ).Mediator;

	// place the mediator in the app attr
	App.mediator = new Mediator;

	/*
		Mediator usage
	App.mediator.subscribe("wat", function(param1, param2){ console.log(param1, param2); });

	setTimeout(function () {

		App.mediator.publish("wat", 7, "hi", { one: 1 });

	}.bind(this), 1000);
	*/

}());
},{"./components/all.js":6,"./config.js":10,"./globals.js":11,"./helpers.js":12,"./introCredits.js":13,"mediator-js":2}],6:[function(require,module,exports){
console.log('%c all.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	// set required component variables
	var Navbar = require('./navbar.js');
	var Buttons = require('./buttons.js');
	var MainMenu = require('./mainMenu.js');

	// create collection of component variables
	var componentsList = {
		'Navbar': Navbar,
		'MainMenu': MainMenu,
		'Buttons': Buttons
	};

	// iterate and initialise collection of components
	// place it on the main Application object
	for (var name in componentsList) {

		if (!App.hasOwnProperty(name)) {

			App[name] = new componentsList[name]();

			// displays in the console the status of the component for development only
			if (typeof App[name] !== 'undefined') {
				console.log('%c ' + name + ' component initialised!', 'background: #AEA; padding: 2px; color: #999');
			}

		} else {

			throw "Components intialisation error: Name collision detected, you're trying to initialise an object named after an existing property in the main App object, please fix!";

		}

	}

}(window.App));
},{"./buttons.js":7,"./mainMenu.js":8,"./navbar.js":9}],7:[function(require,module,exports){
console.log('%c buttons.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	"use strict";

	function Buttons () {
		this.init();
	}

	Buttons.prototype = {
		init: function () {

		}
	};

	module.exports = Buttons;

}(window.App));
},{}],8:[function(require,module,exports){
console.log('%c mainMenu.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	"use strict";

	function MainMenu (params) {
		this.init(params);
		this.setEventListeners();
	}

	MainMenu.prototype = {

		init: function (params) {
			this.header = document.querySelector('header');
			this.mainMenu = document.querySelector('.main-menu');
			this.mainMenuOptList = document.querySelectorAll('li.drop-down');
			this.layerBottom = document.querySelector('header .layer-bottom');
			this.menuDropDownContainer = document.querySelector('.menu-drop-down-container');
			this.timelineDropdown = undefined;
			this.hasParentElement = App.helpers.hasParentElement;
			this.menuCategories = this.menuDropDownContainer.querySelector('.menu-categories');
			this.categoryMenus = document.querySelectorAll('.menu-categories [data-category]');
			this.darkOverlay = document.querySelector('.dark-overlay');
			this.discoveryModule = document.querySelector('.dd-bottom-discoveries');
			this.discoveryModuleHeight = 176;
		},

		setEventListeners: function () {

			_.forEach(this.mainMenuOptList, function(v, k) {
				this.mainMenuOptList[k].addEventListener('click', _.throttle(this.menuOptionHandler.bind(this), 800));
			}.bind(this));

			document.body.addEventListener('click', this.dropDownMenuStateHandler.bind(this));

		},

		menuOptionHandler: function (e) {

			this.resetActiveItem();

			var el = e.target;

			// read attr data category name to use to reveal category module
			// that is nested in the drop down container
			var category = el.getAttribute('data-category');

			el.classList.add('active');

			if (typeof this.timelineDropdown === 'undefined') {

				this.timelineDropdown = new TimelineLite({
					onStart: function () {
						this.menuCategories.style.opacity = 1;
						this.header.classList.add('drop-down-menu-open');
						TweenLite.to(this.darkOverlay, 0.3, { opacity: 0.3, onStart: function () {
								this.darkOverlay.style.display = 'block';
							}.bind(this)
						});
					}.bind(this),

					onReverseComplete: function () {
						this.header.classList.remove('drop-down-menu-open');
						this.resetActiveItem();
						this.resetCategoryMenuVisibility();
					}.bind(this),

					onComplete: this.revealCategoryMenu.bind(this, category)
				});

				this.timelineDropdown.to(this.layerBottom, 0.3, { css: { y: 0 } });

			} else {

				// modify the onComplete event callback to use current category name
				this.timelineDropdown.eventCallback("onComplete", this.revealCategoryMenu.bind(this, category));

				// play cached timeline
				this.timelineDropdown.play();

			}

		},

		resetActiveItem: function () {

			_.forEach(this.mainMenuOptList, function(v, k) {
				this.mainMenuOptList[k].classList.remove('active');
			}.bind(this));

		},

		dropDownMenuStateHandler: function (e) {

			// close the drop down menu, if it's status is open and clicked outside the element
			// if the dd menu is open and different category selection only change the dd menu options
			if (this.header.classList.contains('drop-down-menu-open')) {

				if (this.hasParentElement(e.target, this.mainMenu)) {

					return null;

				} else if (!this.hasParentElement(e.target, this.menuDropDownContainer) && e.target !== this.menuDropDownContainer) {

					var callback = function () {
						this.timelineDropdown.reverse();
					};

					this.resetMenuCategoryHeight(callback);

				}

			}

		},

		revealCategoryMenu: function (category) {

			// reset visibility of all category modules
			this.resetCategoryMenuVisibility();

			var element = this.menuDropDownContainer.querySelector('[data-category="' + category + '"]');

			// prevent running if element doesn't exist
			// and close the drop down container if in open state
			if (!element) {

				var callback = function () {
					this.timelineDropdown.reverse();
				};

				this.resetMenuCategoryHeight(callback);

				return;

			}

			var tl = new TimelineLite({

				onStart: function () {

					element.classList.remove('hiden');

					setTimeout(function () {
						TweenLite.to(this.menuCategories, 0.3, { css: { height: this.discoveryModuleHeight + element.offsetHeight + 'px' } });
					}.bind(this), 0);

				}.bind(this),

				onComplete: function () {

				}.bind(this)

			});

			tl.to(element, 0.6, { opacity: 1 }, 0.4);

			tl.to(this.discoveryModule, 0.6, { opacity: 1 }, 0);

		},

		resetCategoryMenuVisibility: function () {

			_.forEach(this.categoryMenus, function (v, k) {
				this.categoryMenus[k].classList.add('hiden');
				this.categoryMenus[k].style.opacity = '';
			}.bind(this));

		},

		resetMenuCategoryHeight: function (callback) {

			// hide the dark overlay first
			TweenLite.to(this.darkOverlay, 0.3, { opacity: 0, onComplete: function () {
					this.darkOverlay.style.display = '';
				}.bind(this)
			});

			// hide the categories container
			var tl = new TimelineLite();

			tl.to(this.menuCategories, 0.3, { css: { opacity: 0 } });

			// minimize the menu categories and then reverse timelineDropdown animation
			tl.to(this.menuCategories, 0.3, { css: { height: '0px' }, onComplete: function () {
					if (typeof callback === "function") {
						callback.call(this);
					}
				}.bind(this)
			}, 0.3);

		}

	};

	module.exports = MainMenu;

}(window.App));
},{}],9:[function(require,module,exports){
console.log('%c navbar.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	"use strict";

	function Navbar () {
		this.init();
	}

	Navbar.prototype = {
		init: function () {
			this.setProperties();
			this.setEventListeners();
		},

		setProperties: function () {
			this.header = document.querySelector('header');
			this.header_height = getComputedStyle(this.header).height.split('px')[0];
			this.fixedClassName = 'minimize';
			this.headerLogo = document.querySelector('.header-logo img');
			this.headerLogoMinimal = document.querySelector('.header-logo-minimal img');
			this.nav = document.querySelector('nav');
			this.topMenuList = this.header.querySelectorAll('.tm');
			this.topMenuLeftLiList = this.topMenuList[0].querySelectorAll('li');
			this.navOffset = '20px';
			this.topMenuLeftRightOffset = '54px';
			this.tl;
			this.tlPos;
			this.pageOffsetBreakpoint = 10;
		},

		setEventListeners: function () {

			// Scroll handler to toggle classes.
			window.addEventListener('scroll', this.stickyScroll.bind(this), false);

		},

		stickyScroll: function (e) {

			this.fixNavbar(e);

			if( window.pageYOffset > this.pageOffsetBreakpoint ) {
				if (typeof this.tl === 'undefined') {
					this.setTimelineAnim();
				} else {
					this.tl.play();
				}
			}

			if( window.pageYOffset < this.pageOffsetBreakpoint ) {
				if (typeof this.tl === 'undefined') {
					this.setTimelineAnim();
				} else {
					this.tl.reverse();
				}
			}

		},

		fixNavbar: function (event) {

			var y = window.pageYOffset,
				maxY = 55,
				vendorTransform = Modernizr.prefixed('transform');

			if (y < maxY) {

				this.header.style[vendorTransform] = 'translateY(' + (-y + 'px') + ')';

			} else {

				this.header.style[vendorTransform] = 'translateY(' + (-maxY) + 'px)';

			}

		},

		setTimelineAnim: function () {

			this.tl = new TimelineLite({
				onStart: function () {
					this.header.classList.add('minimized');
				}.bind(this),
				onReverseComplete: function () {
					this.header.classList.remove('minimized');
				}.bind(this)
			});

			this.tlPos = 0;
			this.tl.to(this.headerLogo, 0.3, { scale: 0 }, this.tlPos);
			this.tl.to(this.headerLogoMinimal, 0.3, { opacity: 1, scale: 1 }, 0.1);
			this.tl.to(this.nav, 0.3, { css: { y: this.navOffset }}, this.tlPos);

			for (var y = 0; y < this.topMenuLeftLiList.length; y++) {

				this.tl.to(this.topMenuLeftLiList[y], 0.2, { css: { width: '16px' } }, 0.2);

			}

			for (var i = 0; i < this.topMenuList.length; i++) {

				this.tl.to(this.topMenuList[i], 0.3, { css: { y: this.topMenuLeftRightOffset }}, this.tlPos);

			}

		}


	};

	module.exports = Navbar;

}(window.App));
},{}],10:[function(require,module,exports){
console.log('%c config.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	"use strict";

	var config = {};

	module.exports = config;

}(window.App));
},{}],11:[function(require,module,exports){
console.log('%c globals.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function (App) {

	"use strict";

	require('./polyfills');

}(window.App));
},{"./polyfills":14}],12:[function(require,module,exports){
/* global module */

console.log('%c helpers.js loaded!', 'background: #0C0; padding: 2px; color: #FFF');

(function(App) {

	"use strict";

	function Helpers() {

	}

	Helpers.prototype = {
		hasParentElement: function (el, parentEl) {
			while (el.parentNode) {
			    el = el.parentNode;
			    if (el === parentEl) {
			        return true;
			    }
			}
			return false;
		}
	};

	module.exports = Helpers;

}(window.App));
},{}],13:[function(require,module,exports){
(function () {

	"use strict";

	//var css = "font-size: 18px; text-shadow: -1px -1px hsl(0,300%,70%), 1px 1px hsl(2.4, 100%, 50%), 3px 2px hsl(43.8, 100%, 50%), 5px 3px hsl(16.2, 100%, 50%), 7px 4px hsl(21.6, 100%, 50%), 9px 5px hsl(27, 100%, 50%), 11px 6px hsl(72.4, 100%, 50%), 13px 7px hsl(37.8, 100%, 50%), 14px 8px hsl(43.2, 100%, 50%), 16px 9px hsl(48.6, 100%, 50%), 18px 10px hsl(54, 100%, 50%), 20px 11px hsl(59.4, 100%, 50%), 22px 12px hsl(64.8, 100%, 50%), 23px 13px hsl(70.2, 100%, 50%), 25px 14px hsl(75.6, 100%, 50%), 27px 15px hsl(81, 100%, 50%), 28px 16px hsl(86.4, 100%, 50%), 30px 17px hsl(91.8, 100%, 50%), 32px 18px hsl(97.2, 100%, 50%), 33px 19px hsl(102.6, 100%, 50%), 35px 20px hsl(108, 100%, 50%), 36px 21px hsl(113.4, 100%, 50%), 38px 22px hsl(118.8, 100%, 50%), 39px 23px hsl(124.2, 100%, 50%), 41px 24px hsl(129.6, 100%, 50%), 42px 25px hsl(135, 100%, 50%), 43px 26px hsl(140.4, 100%, 50%), 45px 27px hsl(145.8, 100%, 50%), 46px 28px hsl(151.2, 100%, 50%), 47px 29px hsl(156.6, 100%, 50%), 48px 30px hsl(162, 100%, 50%), 49px 31px hsl(167.4, 100%, 50%), 50px 32px hsl(172.8, 100%, 50%), 51px 33px hsl(178.2, 100%, 50%), 52px 34px hsl(183.6, 100%, 50%), 53px 35px hsl(189, 100%, 50%), 54px 36px hsl(194.4, 100%, 50%), 55px 37px hsl(199.8, 100%, 50%), 55px 38px hsl(205.2, 100%, 50%), 56px 39px hsl(210.6, 100%, 50%), 57px 40px hsl(216, 100%, 50%)";
	var css = "font-size: 14px; color: #FFF; text-shadow: -1px -1px 10px #FF0000, 2px 2px 20px #FF0055, 5px 8px 30px #FFAACC, 1px -2px 5px #FF4400";
	console.log("%c ♡ Christian Louboutin V4 ♡", css);

}());
},{}],14:[function(require,module,exports){
if (!window.Modernizr.classlist) {
	/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */
	if("document" in self){if(!("classList" in document.createElement("_"))){(function(j){"use strict";if(!("Element" in j)){return}var a="classList",f="prototype",m=j.Element[f],b=Object,k=String[f].trim||function(){return this.replace(/^\s+|\s+$/g,"")},c=Array[f].indexOf||function(q){var p=0,o=this.length;for(;p<o;p++){if(p in this&&this[p]===q){return p}}return -1},n=function(o,p){this.name=o;this.code=DOMException[o];this.message=p},g=function(p,o){if(o===""){throw new n("SYNTAX_ERR","An invalid or illegal string was specified")}if(/\s/.test(o)){throw new n("INVALID_CHARACTER_ERR","String contains an invalid character")}return c.call(p,o)},d=function(s){var r=k.call(s.getAttribute("class")||""),q=r?r.split(/\s+/):[],p=0,o=q.length;for(;p<o;p++){this.push(q[p])}this._updateClassName=function(){s.setAttribute("class",this.toString())}},e=d[f]=[],i=function(){return new d(this)};n[f]=Error[f];e.item=function(o){return this[o]||null};e.contains=function(o){o+="";return g(this,o)!==-1};e.add=function(){var s=arguments,r=0,p=s.length,q,o=false;do{q=s[r]+"";if(g(this,q)===-1){this.push(q);o=true}}while(++r<p);if(o){this._updateClassName()}};e.remove=function(){var t=arguments,s=0,p=t.length,r,o=false,q;do{r=t[s]+"";q=g(this,r);while(q!==-1){this.splice(q,1);o=true;q=g(this,r)}}while(++s<p);if(o){this._updateClassName()}};e.toggle=function(p,q){p+="";var o=this.contains(p),r=o?q!==true&&"remove":q!==false&&"add";if(r){this[r](p)}if(q===true||q===false){return q}else{return !o}};e.toString=function(){return this.join(" ")};if(b.defineProperty){var l={get:i,enumerable:true,configurable:true};try{b.defineProperty(m,a,l)}catch(h){if(h.number===-2146823252){l.enumerable=false;b.defineProperty(m,a,l)}}}else{if(b[f].__defineGetter__){m.__defineGetter__(a,i)}}}(self))}else{(function(){var b=document.createElement("_");b.classList.add("c1","c2");if(!b.classList.contains("c2")){var c=function(e){var d=DOMTokenList.prototype[e];DOMTokenList.prototype[e]=function(h){var g,f=arguments.length;for(g=0;g<f;g++){h=arguments[g];d.call(this,h)}}};c("add");c("remove")}b.classList.toggle("c3",false);if(b.classList.contains("c3")){var a=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(d,e){if(1 in arguments&&!this.contains(d)===!e){return e}else{return a.call(this,d)}}}b=null}())}};
}
},{}]},{},[5]);
